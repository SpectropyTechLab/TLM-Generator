const fs = require('fs/promises');
const path = require('path');
const os = require('os');
const { execFile } = require('child_process');
const PDFCompiler = require('./pdfCompiler');

function execFileAsync(command, args, options) {
  return new Promise((resolve, reject) => {
    execFile(command, args, options, (error, stdout, stderr) => {
      if (error) {
        const err = new Error(stderr || stdout || error.message);
        err.cause = error;
        return reject(err);
      }
      return resolve({ stdout, stderr });
    });
  });
}

function sanitizeLatexForPandoc(latexContent) {
  let text = String(latexContent || '');

  // Normalize malformed display math delimiters: "$$ $x ... $" -> "$$ x ... $$"
  text = text.replace(/\$\$\s*\$([\s\S]*?)\$/g, '$$ $1 $$');

  // Fix common escaped/markdown artifacts.
  text = text
    .replace(/\\"/g, '"')
    .replace(/\\\*{2}/g, '**')
    .replace(/\*\*([^*]+)\*\*/g, '\\textbf{$1}')
    // Escape underscores in plain text (Pandoc LaTeX reader is strict).
    .replace(/__/g, '\\_\\_')
    .replace(/(?<!\\)_/g, '\\_');

  // Convert common Unicode symbols to LaTeX-safe forms.
  text = text
    .replace(/\u2264/g, '\\leq ')
    .replace(/\u2265/g, '\\geq ')
    .replace(/\u2260/g, '\\neq ')
    .replace(/\u2248/g, '\\approx ')
    .replace(/\u00B1/g, '\\pm ')
    .replace(/\u00D7/g, '\\times ')
    .replace(/\u00F7/g, '\\div ')
    .replace(/\u03C0/g, '\\pi ')
    .replace(/\u221E/g, '\\infty ')
    .replace(/\u03B1/g, '\\alpha ')
    .replace(/\u03B2/g, '\\beta ')
    .replace(/\u03B3/g, '\\gamma ')
    .replace(/\u03B4/g, '\\delta ')
    .replace(/\u03B8/g, '\\theta ')
    .replace(/\u03BB/g, '\\lambda ')
    .replace(/\u03BC/g, '\\mu ')
    .replace(/\u03C3/g, '\\sigma ')
    .replace(/\u03C6/g, '\\phi ')
    .replace(/\u03C9/g, '\\omega ')
    .replace(/\u0394/g, '\\Delta ')
    .replace(/\u03A9/g, '\\Omega ');

  // Remove stray HTML markers and braces that can break Pandoc's LaTeX reader.
  text = text
    .replace(/^\s*\{=html\}\s*$/gm, '')
    .replace(/^\s*<!--\s*-->\s*$/gm, '')
    // Remove stray leading braces on their own or before list markers.
    .replace(/^\s*}\s*(?=[a-d]\))/gm, '')
    .replace(/^\s*}\s*(?=\d+[\.\)]\s)/gm, '')
    .replace(/^\s*}\s*/gm, '')
    .replace(/\\textbackslash\{\}/g, '\\textbackslash{}');

  return text;
}

function sanitizeMarkdownForPandoc(markdownContent) {
  let text = String(markdownContent || '');

  // Remove common HTML/markdown artifacts.
  text = text
    .replace(/^\s*\{=html\}\s*$/gm, '')
    .replace(/^\s*<!--\s*-->\s*$/gm, '')
    .replace(/^!\[.*?\]\(.*?\)\s*(\{.*?\})?\s*$/gm, '');

  // Prevent accidental emphasis from underscores in plain text.
  // Keep underscores inside math segments intact by leaving $...$ blocks alone.
  const mathRegex = /(\$\$[\s\S]*?\$\$|\$[^$]*?\$|\\\[[\s\S]*?\\\]|\\\([\s\S]*?\\\))/g;
  const parts = text.split(mathRegex);
  text = parts
    .map((part) => {
      if (!part) return '';
      if (mathRegex.test(part)) return part;
      return part.replace(/(?<!\\)_/g, '\\_');
    })
    .join('');

  return text;
}

class DocxCompiler {
  static async compile(latexContent, worksheetId) {
    const pandocBin = process.env.PANDOC_BIN || 'pandoc';
    const workDir = await fs.mkdtemp(path.join(os.tmpdir(), `p2m-docx-${worksheetId}-`));
    const inputPath = path.join(workDir, 'manual.tex');
    const outputPath = path.join(workDir, 'manual.docx');

    try {
      // Build a full LaTeX document so Pandoc receives valid LaTeX (lists, escaping, etc.).
      const latexDoc = PDFCompiler.buildLatexDocument(latexContent, '', worksheetId);
      const sanitizedLatex = sanitizeLatexForPandoc(latexDoc);
      await fs.writeFile(inputPath, sanitizedLatex, 'utf8');
      try {
        await execFileAsync(pandocBin, ['--from=latex', '--to=docx', inputPath, '-o', outputPath], {
          timeout: 120000,
          windowsHide: true
        });
      } catch (latexError) {
        // Fallback: use markdown input to avoid Pandoc LaTeX reader edge cases.
        const markdownPath = path.join(workDir, 'manual.md');
        const markdownText = sanitizeMarkdownForPandoc(latexContent);
        await fs.writeFile(markdownPath, markdownText, 'utf8');
        await execFileAsync(
          pandocBin,
          ['--from=markdown+tex_math_dollars+raw_tex', '--to=docx', markdownPath, '-o', outputPath],
          { timeout: 120000, windowsHide: true }
        );
      }
      const docxBuffer = await fs.readFile(outputPath);
      return docxBuffer;
    } finally {
      await fs.rm(workDir, { recursive: true, force: true });
    }
  }
}

module.exports = DocxCompiler;
